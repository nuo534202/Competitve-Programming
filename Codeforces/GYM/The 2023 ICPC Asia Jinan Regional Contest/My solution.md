# My solution

Contest Link: https://codeforces.com/gym/104901

My Blog Link: https://blog.csdn.net/djhws144/article/details/144067875?spm=1001.2014.3001.5501

## A. Many Many Heads
括号匹配问题，但不考虑括号的方向。如果括号匹配方式唯一，那么只能是圆括号（ '(' 或 ')' ）和 方括号（ '[' 或 ']' ）交替排列，或者是两组交替排列的括号并且最外层的括号类型不同，例如 "\[()\](\[()\])"。

## D. Largest Digit
给出了 $a$ 和 $b$ 的范围，可以算出 $a + b$ 的范围 $\[l,r\]$，如果区间长度大于等于 $10$，那么 $f(a + b) = 9$，否则直接枚举每一个数找出最大值。

## E. I Just Want... One More...
二分图匹配问题。设立一个源点 $s$ 和汇点 $t$， $s$ 向 $U$ 集合中的每一个点连一条容量为 $1$ 的边， $V$ 集合中的每一个点向 $t$ 连一条容量为 $1$ 的边，$U$ 集合跟 $V$ 集合直接按照题目要求连接一条容量为 $1$ 的边。
对这个图跑一遍最大流，利用 dfs 找出 $s$ 能到达 $U$ 集合中的节点的数量 $x$，以及 $t$ 能到 $V$ 集合中的节点数量 $y$, 最后答案就是 $x \times y$。

dfs 细节：

找 $U$ 集合节点的时候，从 $s$ 节点出发，走所有容量为 $1$ 的边；找 $V$ 集合节点的时候，从 $t$ 节点出发，走所有容量为 $0$ 的边。

但存在一种特殊情况, $U$ 集合多个节点同时连接了 $V$ 集合的同一个节点，这样 $x$ 就不是 $s$ 节点能直接到达点的数量，而是同时连接 $V$ 集合中该节点的所有 $U$ 集合中的节点。

![img](https://i-blog.csdnimg.cn/direct/fed6d452e59848deafa0330c98b87dcc.png)

上图中的 $1$ 号节点代表的是 $s$ 节点， $2$ - $4$ 号节点代表的是 U 集合中的节点， $5$ - $7$ 号节点代表的是 $V$ 集合中的节点，8号节点代表的是 $t$ 节点。 
假设刚开始跑最大流选择的增广路为 $1$ -> $2$ -> $6$ -> $8$，那么 $1$ 号节点能够直接到达的节点为 $3$ 号和 $4$ 号节点，但实际上连边 $(2,5)$ 和 $(2,7)$ 也能让图的匹配数增大，
因为 $2$ 号节点能走新连的边，而 $6$ 号节点可以有另一条增广路 $1$ -> $4$ -> $6$ -> $8$。

但是这种情况并不需要连边后重新跑最大流，统计数量的时候只要从 $1$ 号节点出发，沿着容量为 $1$ 的边统计节点数量就能全部统计进去。上图中可走路径为 $1$ -> $3$, $1$ -> $4$ -> $6$ -> $2$, $2$ 号节点能由 $6$ 号节点到达。

## G. Gifts from Knowledge
- 每一列本身和对称的列加起来最多只能有 $2$ 个 $1$，否则没有合法答案。
- 如果同一列有两个 $1$，则这两个 $1$ 所在行的反转情况相反；
- 如果一列本身和对称的列各有一个 $1$，则这两个 $1$ 所在行的反转情况相同。
考虑建一个并查集，初始化 $f_i = i$，对于后面两种情况，假设两个 $1$ 的所在列分别为 $x$, $y$。

- 第二种情况则将 $x + r$ 和 $y$ 相连, $x$ 和 $y + r$ 相连。
- 第三种情况则将 $x$ 和 $y$ 相连, $x + r$ 和 $y + r$ 相连。

如果最后处理完存在一个位置 $i$，使得 $find(i) = find(i + r)$，那么也没有合法答案。最后统计并查集连通块个数，如果连通块个数为 $2x$，那么答案数量为 $2^x$。

## I. Strange Sorting
假设每次选取区间的左端点 $l$ 固定，对于右端点 $r$，在满足条件 $l < r$ 和 $a_l > a_r$ 的情况下，$r$ 肯定是越靠右会越优。

每次操作只需要找到一个最小的 $l$，满足 $a_l \not= l$，再找到一个最大的 $r$，这样进行一次排序之后，区间 $\[l,r\]$ 有序，并且至少满足 $a_l = l$ 和 $a_{l + 1} = l + 1$，所以最多只需要 $\lfloor \frac{n}{2} \rfloor$ 次操作。

## K. Rainbow Subarray
$a_{i + 1} - a_i = 1$ 等价于 $a_i - i = a_j - j$。对数组 $a$ 的每一位，减去其对应的下标后，问题就变成了找出在 $k$ 次操作内最长的相等序列。

对于固定的一段序列，把他们变成相等的序列最优的操作就是把每一位变成这段序列的<b>中位数</b>。

本题可以利用滑动窗口来求解，判断窗口序列能否在 $k$ 次操作内变成全部相等的。对于任意一段滑动窗口的序列，最少操作次数即为<b>所有大于等于中位数的和</b>减去<b>所有小于等于中位数的和</b>。

$$
\sum_{i = l, a_i \le x}^r(x - a_i) - \sum_{j = l, a_j \le x}^r(a_j - x)= \sum_{i = l, a_i \le x}^ra_i - \sum_{j = l, a_j \le x}^ra_j
$$

可以用两个 multiset 分别记录小于等于中位数的值和大于中位数的值，并同时记录两个 $multiset$ 中的值的和。
