比赛链接：[CF1023](https://codeforces.com/contest/2107)

# A. LRC and VIP

- 如果 $a$ 数组全部值都相同，则无法构造出满足条件的 $B$, $C$ 序列。
- 否则，将最大值放到 $C$ 序列中，其余元素放到 $B$ 序列中。

时间复杂度： $O(n)$。

# B. Apples in Boxes

Jerry 获胜条件：

- 当前最大值 $- 1$ 后，剩余所有元素的最大值 $-$ 最小值 $> k$。
- 操作一次后，剩余所有元素数量的和为偶数。

剩余情况都是 Tom 获胜。

时间复杂度： $O(n)$。

# C. Maximum Subarray Sum

- 如果 $s_i$ 全为 1，无法进行操作，利用 $dp$ 找出最大连续子数组，并且判断是否等于 $k$。
- 如果存在 $s_i = 0$，根据题目数据范围，只需要一个位置就可以让最大连续子数组的值等于 $k$。
	- 找到第一个 $s_i = 0$ 的位置，算出这个位置前面的一段最大后缀 $suf$，跟这个位置往后的最大前缀 $pre$，这个位置的 $a_i$ 直接赋值为 $k - pre - suf$。
	- 第二个 $s_i = 0$ 的位置，将 $a_i$ 赋值为 $-10^{18}$，其余位置不需要改变。

时间复杂度：$O(n)$。

# D. Apple Tree Traversing

可以发现按照字典序排列的第一关键字是 $d$，也就是路径长度，所以只需要每一次在剩余森林的每一棵树中找出直径，并且存下这条直径的长度以及端点，最后按照字典序排列即可。

时间复杂度： $O(n \sqrt{n})$。

- 每一次找的直径一定会比前面的短，所以最多需要找 $\sqrt{n}$ 次直径。

# E. Ain and Apple Tree

- 可以发现，当构造出来的树是一条链的时候答案最大，答案为 $\sum_{i = 0}^{n - 1}i \cdot (n - i - 1)$。
	- 如果 $k > \sum_{i = 0}^{n - 1}i \cdot (n - i - 1) + 1$，则无解。
- 将一条链状的树的最深节点往上移到比其深度小 $x$ 的节点的地方时，最后答案会减小 $1 + 2 + \ldots + x - 1 = \frac{x(x - 1)}{2}$。
- 我们可以将要构造的树初始化为链状，然后将最深节点依次上移，直到 $|\sum_{i = 1}^n\sum_{j = i + 1}^ndep(lca(i, j)) - k| < 1$。

时间复杂度： $O(n)$。

# F1. Cycling (Easy Version)

- 当 $a_{[x,y)} >= a_y + 1$ 时，每次将 $y$ 前移一定不会使答案更劣，因为这种操作的花费为 $a_y + 1$，其中 $1$ 是前移的花费。
- 如果 $a_y$ 要后移到位置 $z$，Leo 超越到位置 $x$ 的花费为 $cost_{[z + 1, n]} + (z - y) \cdot a_y + (z - y) + (z - x - 1)$。

时间复杂度： $O(n^2)$。
