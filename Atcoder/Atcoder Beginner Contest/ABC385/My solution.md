# My solution
Contest Link: https://atcoder.jp/contests/abc385

## A - Equally
只有三个数相等或者两个小的数加起来等于最大的数时输出 $Yes$，其他时候输出 $No$。

时间复杂度： $O(1)$。

## B - Santa Claus 1
按照题意模拟，用 $vis$ 数组记录经过的格子，最后统计这些格子中房子 ($@$) 的个数。

时间复杂度： $O(HW + |T|)$ ($|T|$ 代表字符串 $T$ 的长度)。

## C - Illuminate Buildings
设 $dp_{i, j}$ 表示考虑到第 $i$ 位，间隔为 $j$ 能装饰的建筑物数量。当 $h_i = h_{i - j}$ 时，状态转移方程为 $dp_{i, j} = max(dp_{i, j}, dp_{i - j, j} + 1)$。

时间复杂度： $O(N^2)$。

## D - Santa Claus 2
按照题意模拟过程。

找房子的方法：
- 用两个 $vector$ $vx$ 和 $vy$ 分别存房子的坐标 $(x, y)$ 和对应的 $(y, x)$ 并进行排序。
- 在上下移动的时候，利用二分在 $vx$ 中找出经过的点存入 $set$ 里面。
- 在左右移动的时候，利用二分在 $vy$ 中找出经过的点存入 $set$ 里面。

时间复杂度： $O(Mlog^2N)$。

## E - Snowflake Tree
可以发现在中心点和 $x$ 确定之后，整棵雪花树就可以确定下来了。
对于每一组中心点和 $x$，整棵雪花树的节点数量为 $x * min(deg_{1 \le i \le x}) + 1$，其中 $deg$ 表示那 $x$ 个节点对应的度数。

按照贪心的思想，我们可以枚举中心点，将中心点相邻的点按照度数从大到小进行排序 ($x$ 相同的情况下 $min(deg_{1 \le i \le x})$ 越大，结果越优，所以要取最大的 $x$ 个节点)。
枚举 $x$，计算出对应的节点数量，就可以找到最大的节点数了。

## F - Visible Buildings
取相邻的两个建筑物，将这两个建筑物的顶点连一条直线，所有之前的截距的最大值就是答案。

为什么要取相邻的：可以证明如果两个建筑物之间还有建筑物，无论中间的建筑物是在直线的上方或者下方，中间的建筑物与两边建筑物的连线至少有一条的截距都大于两端建筑物连线的截距。所以对于同组数据，取相邻的两个建筑物连直线截距一定最大。

对于给定两个建筑物，可以根据建筑物顶点坐标 $(x_{i - 1}, h_{i - 1}$ 和 $(x_i, h_i)$ ($2 \le i \le N$) 算出直线的方程。

直线方程为： $y - h_i = \frac{h_i - h_{i - 1}}{x_i - x_{i - 1}}(x - x_i)$，即 $y = \frac{h_i - h_{i - 1}}{x_i - x_{i - 1}} x + h_i - \frac{h_i - h_{i - 1}}{x_i - x_{i - 1}} x_i$

截距为： $h_i - \frac{h_i - h_{i - 1}}{x_i - x_{i - 1}} x_i$
