比赛链接：[Atcoder Beginner Contest 406](https://atcoder.jp/contests/abc406)

Github 链接：[ABC406](https://www.cnblogs.com/nuo534202/articles/18947606)

# A - Not Acceptable

将小时转换成分钟直接进行判断。

时间复杂度： $O(1)$。

# B - Product Calculator

根据题意进行模拟，为了避免 overflow 可以使用 `__int128_t` 来储存计算器当前展示的值。

时间复杂度： $O(N + K)$。

# C - ~

- 根据题目条件可知，要找的波浪形的子数组，一定先增大在减小最后再增大。
- 我们只需要找到一个连续递减部分，再在这个连续递减的部分两侧加上至少一个数就能构造出满足题目条件的子数组。
- 每一个连续递减部分能构成的满足题目条件的子数组的数量为这个部分 前面连续递增的长度 $\times$ 后面连续递增的长度。
- 因此，只需要找到原数组每个连续递增部分的长度，答案即为所有两个相邻的连续递增部分的长度的乘积的和。

时间复杂度： $O(N)$。

# D - Garbage Removal

对于每一个行、列分别用一个 `set` 维护这一行中的点的纵、横坐标，每次查询完将对应的点的坐标从 `set` 中删除。

时间复杂度： $O(\sum_{i = 1}^Q T\log N + N\log N)$，其中 $T$ 是每次需要删除的点的数量，并且 $\sum_{i = 1}^Q T\log N \le N\log N$。

# E - Popcount Sum 3

从高位往低位考虑，总共放置 $k$ 个 $1$，利用 $dfs$ 找出答案，具体实现看代码。

时间复杂度： $O(\sum_{i = 1}^Ti\log N)$。

从高位往地位进行搜索，

- 如果每一位都放 $1$，最多进行 $\log N$ 次 $sum$ 就会大于 $N$。
- 如果前面都不放 $1$，最多进行 $\log N - K$ 次就会被剪枝。
