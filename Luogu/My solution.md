# My solution

Link of Luogu: https://www.luogu.com.cn/

The solutions are sorted by the first letter in ascending order.

## P1816 忠诚
本题只需要利用线段树维护区间内的最小值，然后在接下来的操作中查询区间最小值即可。

本题只有查询操作没有修改操作，所以不需要 $pushDown$ 函数。

## P1908 逆序对
利用树状数组 / 线段树：首先对所有数字由大到小排序，相同大小的数字则原先排在后面的放到前面，接着从头开始遍历，统计在该数字位置之前出现过的数字数量。

利用归并排序：利用归并排序将该列数字从大到小排序，并同时统计逆序对数量。

## P3368 【模板】树状数组 2
本题虽然要进行区间修改，但是由于只需要进行区间查询所以也可以用树状数组来写。

我们可以用一个差分数组 $b$ 来存 $a$ 数组的差 $b\[i\] = a\[i\] - a\[i - 1\]$，对a数组的 $\[x, y\]$ 区间加上 $k$，相当于对 $b$ 数组的第 $x$ 位加 $k$，第 $y + 1$ 为减 $k$。

## P3372 【模板】线段树 1
模板题。区间修改，区间查询。

## P3373 【模板】线段树 2
模板题。区间修改，区间查询。先乘后加。在运算中要及时对m取余避免overflow。

## P3374 【模板】树状数组 1
本题由于是单点修改，所以每次修改都是从最底层开始的，因此也不需要 $pushDown$ 函数和打延迟标记， $modify$ 函数的递归终止条件也有所变化。
对于区间修改的线段树来说 $modify$ 函数的终止条件应为 $ql \le l$ && $r \le qr$，但是单点修改相当于是区间左右边界都相等的区间修改，即 $ql = qr$，所以递归终止条件可以简写为 $l = r$。

本题显然用树状数组来写会更简单，而且运行效率也会更快（省了将近一半时间）。

## P3870 [TJOI2009] 开关
可以利用线段树来存区间内开着的灯的数量，进行第一种操作时（把开着的灯关上，关着的灯打开）
只需要将 $t[p].num$ 改成 $r - l + 1 - t[p].num$ 即可
（原本开着的 $t[p].num$ 盏灯在操作后被关上了，用所有区间内所有灯的数量减去关着的灯的数量就是开着的灯的数量）。

## P4513 小白逛公园
本题难点在于理解如何利用线段树在一段存在负数的区间找到最大的连续区间的和（连续区间的和即为一段连续区间内每一位的数的和，一下简称连续和）。
对于每一段的区间，我们可以用线段树存下区间和 $sum$，从左端点出发的最大连续和 $lm$，从右端点出发的最大连续和 $rm$，整个区间最大连续和 $am$。

当递归到最底层的时候， $sum = lm = rm = am = a\[l\]$，然后再向上传递（具体看代码）。

单点修改所以不需要 pushDown 函数，详细解释看 P3374。

对线段树进行访问的时候，函数返回类型为定义的结构体 $tree$，即将整个节点全部信息返回，方便下一步的查找最大连续和。
